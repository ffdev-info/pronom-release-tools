<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.pronom_stats.pronom_stats API documentation</title>
<meta name="description" content="PRONOM stats server to be hosted on ffdev.info …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.pronom_stats.pronom_stats</code></h1>
</header>
<section id="section-intro">
<p>PRONOM stats server to be hosted on ffdev.info.</p>
<p>The app allows us to record statistics about PRONOM that can then be
used to guide signature development work.</p>
<p>The goal of this API is to have a "put" endpoing that can receive
information about the latest information available on the PRONOM
server.</p>
<p>Whether this goal is required, schauen wir mal.</p>
<pre><code>`uvicorn pronom_stats:app --reload`
</code></pre>
<p>The database for this app is stored in <code>/var/tmp/pronom-stats.db</code>. The
location can be cleared manually if necessary. Data will persist at
reboot time otherwise. It's not hugely important to the functioning
of this app.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;PRONOM stats server to be hosted on ffdev.info.

The app allows us to record statistics about PRONOM that can then be
used to guide signature development work.

The goal of this API is to have a &#34;put&#34; endpoing that can receive
information about the latest information available on the PRONOM
server.

Whether this goal is required, schauen wir mal.

    `uvicorn pronom_stats:app --reload`

The database for this app is stored in `/var/tmp/pronom-stats.db`. The
location can be cleared manually if necessary. Data will persist at
reboot time otherwise. It&#39;s not hugely important to the functioning
of this app.
&#34;&#34;&#34;

# pylint: disable=E1101,R0801

import argparse
import functools
import hashlib
import importlib
import json
import logging
import os
import sqlite3
import time
from contextlib import asynccontextmanager
from typing import Annotated, Final

import uvicorn
from dotenv import load_dotenv
from fastapi import FastAPI, Header, HTTPException, Request, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, RedirectResponse

# Set up logging.
logging.basicConfig(
    format=&#34;%(asctime)-15s %(levelname)s :: %(filename)s:%(lineno)s:%(funcName)s() :: %(message)s&#34;,  # noqa: E501
    datefmt=&#34;%Y-%m-%d %H:%M:%S&#34;,
    level=&#34;INFO&#34;,
    handlers=[
        logging.StreamHandler(),
    ],
)

# Format logs using UTC time.
logging.Formatter.converter = time.gmtime


logger = logging.getLogger(__name__)

ENV_FILE: Final[str] = &#34;pronom.env&#34;


async def init_db(cur: sqlite3.Cursor):
    &#34;&#34;&#34;Initialize the database if it doesn&#39;t exist.&#34;&#34;&#34;
    try:
        cur.execute(&#34;CREATE TABLE pronom(version, summary)&#34;)
    except sqlite3.OperationalError:
        # database is already setup.
        pass


def _escape_ins(ins: str) -&gt; str:
    &#34;&#34;&#34;Provides a way to escape the data we&#39;re inserting. It&#39;s a bit
    of a hack. First created to handle single-quotes but will
    potentially be needed for other character types.
    &#34;&#34;&#34;
    return ins.replace(&#34;&#39;&#34;, &#34;&#34;)


async def _insert_version(version: str, summary: str):
    &#34;&#34;&#34;Deleteme&#34;&#34;&#34;
    summary = _escape_ins(summary)
    ins = f&#34;insert into pronom (version, summary) values (&#39;{version}&#39;, &#39;{summary}&#39;);&#34;
    app.cur.execute(ins)
    app.cur.execute(&#34;commit;&#34;)
    return


def _load_config():
    &#34;&#34;&#34;Ensure the config is properly loaded.&#34;&#34;&#34;
    load_dotenv(ENV_FILE, override=False, verbose=True)
    try:
        os.environ[&#34;SERVER_AUTH&#34;]
    except KeyError as err:
        logging.error(
            &#34;environment needs configuring: %s (e.g. SERVER_AUTH=&#39;badf00d&#39;)&#34;, err
        )
        raise err


@asynccontextmanager
async def lifespan(context: FastAPI):
    &#34;&#34;&#34;Load the database connection for the life of the app.s&#34;&#34;&#34;
    _load_config()
    con = sqlite3.connect(os.path.join(&#34;/var&#34;, &#34;tmp&#34;, &#34;pronom-stats.db&#34;))
    context.cur = con.cursor()
    await init_db(context.cur)
    yield


#### API Entry Points ####

# API description.
API_DESCRIPTION: Final[str] = &#34;ffdev.info PRONOM API&#34;

# OpenAPI tags delineating the documentation.
TAG_PRONOM: Final[str] = &#34;pronom&#34;

# Metadata for each of the tags in the OpenAPI specification. To order
# their display on the page, order the tags in this block.
tags_metadata = [
    {
        &#34;name&#34;: TAG_PRONOM,
        &#34;description&#34;: &#34;Manage PRONOM data&#34;,
    },
]

app = FastAPI(
    title=&#34;api.pronom.ffdev.info&#34;,
    description=API_DESCRIPTION,
    version=&#34;0.0.1&#34;,
    contact={
        &#34;Github&#34;: &#34;https://github.com/ross-spencer/&#34;,
    },
    openapi_tags=tags_metadata,
    lifespan=lifespan,
)

origins = [
    &#34;http://127.0.0.1:26001&#34;,
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=[&#34;*&#34;],
    allow_headers=[&#34;*&#34;],
    expose_headers=[&#34;X-Content-type&#34;],
)


@app.get(&#34;/&#34;, include_in_schema=False)
def redirect_root_to_docs():
    &#34;&#34;&#34;Redirect a user calling the API root &#39;/&#39; to the API
    documentation.
    &#34;&#34;&#34;
    return RedirectResponse(url=&#34;/docs&#34;)


@app.get(&#34;/pronom_summary&#34;, tags=[TAG_PRONOM])
async def get_pronom_summary():
    &#34;&#34;&#34;Retrieve the PRONOM summary information from the database.

    Result should looks something like as follows:

    ```json
        {
            &#34;version&#34;: &#34;v116&#34;,
            &#34;summary&#34;: {
                &#34;date&#34;: &#34;2023-11-23&#34;,
                &#34;latest_puid&#34;: &#34;fmt/1924&#34;,
                &#34;version&#34;: &#34;V116&#34;,
                &#34;sig_file&#34;: &#34;https://cdn.nationalarchives.gov.uk/documents/DROID_SignatureFile_V116.xml&#34;,
                &#34;container_sig&#34;: &#34;https://cdn.nationalarchives.gov.uk/documents/container-signature-20231127.xml&#34;,
                &#34;xpuid_const&#34;: &#34;x-fmt/455&#34;,
                &#34;pronom_data&#34;: [
                    {
                        &#34;name&#34;: &#34;Broadcast WAVE 0 Generic&#34;,
                        &#34;description&#34;: &#34;complete&#34;,
                        &#34;signature&#34;: true,
                        &#34;identifier&#34;: &#34;fmt/1&#34;
                    },
                    {
                        &#34;name&#34;: &#34;Microsoft Word for Macintosh Document 3.0&#34;,
                        &#34;description&#34;: &#34;complete&#34;,
                        &#34;signature&#34;: true,
                        &#34;identifier&#34;: &#34;x-fmt/1&#34;
                    }
                ]
            }
        }
    ```
    &#34;&#34;&#34;
    res = app.cur.execute(
        &#34;select version, summary from pronom order by rowid desc limit 1;&#34;
    )
    res = res.fetchone()
    ret = {}
    ret[&#34;version&#34;] = res[0]
    ret[&#34;summary&#34;] = json.loads(res[1])
    return ret


@app.get(&#34;/pronom_version&#34;, tags=[TAG_PRONOM], response_class=HTMLResponse)
async def get_pronom_version() -&gt; str:
    &#34;&#34;&#34;Retrieve the PRONOM version from the database.&#34;&#34;&#34;
    res = app.cur.execute(&#34;select version from pronom order by rowid desc limit 1;&#34;)
    res = res.fetchone()
    return res[0]


@functools.cache
def _get_summary() -&gt; dict:
    &#34;&#34;&#34;Return the PRONOM summary from the database.&#34;&#34;&#34;
    res = app.cur.execute(&#34;select summary from pronom order by rowid desc limit 1;&#34;)
    res = res.fetchone()
    return json.loads(res[0])


@app.get(&#34;/records_count&#34;, tags=[TAG_PRONOM])
async def get_complete_records_count():
    &#34;&#34;&#34;Retrieve the PRONOM version from the database.&#34;&#34;&#34;
    summary = _get_summary()
    return len(summary.get(&#34;pronom_data&#34;, []))


@app.get(&#34;/complete_description_count&#34;)
async def get_complete_descriptions_count():
    &#34;&#34;&#34;Retrieve the number of PRONOM descriptions with status complete.&#34;&#34;&#34;
    summary = _get_summary()
    complete = [
        item
        for item in summary.get(&#34;pronom_data&#34;, [])
        if item[&#34;description&#34;] == &#34;complete&#34;
    ]
    return len(complete)


@app.get(&#34;/incomplete_description_count&#34;)
async def get_incomplete_descriptions_count():
    &#34;&#34;&#34;Retrieve the number of PRONOM descriptions with status complete.&#34;&#34;&#34;
    summary = _get_summary()
    complete = [
        item
        for item in summary.get(&#34;pronom_data&#34;, [])
        if item[&#34;description&#34;] != &#34;complete&#34;
    ]
    return len(complete)


@app.get(&#34;/signature_count&#34;)
async def get_signatures_count():
    &#34;&#34;&#34;Retrieve the number of PRONOM descriptions with status complete.&#34;&#34;&#34;
    summary = _get_summary()
    signatures = [
        item for item in summary.get(&#34;pronom_data&#34;, []) if item[&#34;signature&#34;] is True
    ]
    return len(signatures)


@app.get(&#34;/requires_signature_count&#34;)
async def get_requires_signatures_count():
    &#34;&#34;&#34;Retrieve the number of PRONOM descriptions where signatures are
    still required.
    &#34;&#34;&#34;
    summary = _get_summary()
    signatures = [
        item for item in summary.get(&#34;pronom_data&#34;, []) if item[&#34;signature&#34;] is not True
    ]
    return len(signatures)


@app.get(&#34;/signature_files&#34;, response_class=HTMLResponse)
async def get_signature_files():
    &#34;&#34;&#34;List the signature files associated with the latest PRONOM
    release.
    &#34;&#34;&#34;
    summary = _get_summary()
    standard_sig = summary.get(&#34;sig_file&#34;)
    container_sig = summary.get(&#34;container_sig&#34;)
    return (
        f&#34;&lt;br&gt;&#34;
        f&#34;&lt;ul&gt;&#34;
        f&#34;&lt;li&gt;Standard signature file: &lt;a href=&#39;{standard_sig}&#39;&gt;{standard_sig}&lt;/a&gt;&lt;/li&gt;&#34;
        f&#34;&lt;li&gt;Container signature file: &lt;a href=&#39;{container_sig}&#39;&gt;{container_sig}&lt;/a&gt;&lt;/li&gt;&#34;
        f&#34;&lt;/ul&gt;&#34;
    )


def _make_url_from_identifier(identifier: str) -&gt; str:
    &#34;&#34;&#34;Make a PRONOM URL from its inentifier.&#34;&#34;&#34;
    url_pattern = &#34;https://www.nationalarchives.gov.uk/PRONOM/&#34;
    return f&#34;&lt;a href=&#39;{url_pattern}{identifier}&#39;&gt;{identifier}&lt;/a&gt;&#34;


def _make_formatted_list_from_summary_items(summary_objs: list) -&gt; str:
    &#34;&#34;&#34;Make a formatted list from a list of summary items.

    Example item:

    ```json
            {
            &#34;name&#34;: &#34;Microsoft Word for Macintosh Document 3.0&#34;,
            &#34;description&#34;: &#34;incomplete&#34;,
            &#34;signature&#34;: true,
            &#34;identifier&#34;: &#34;x-fmt/1&#34;
        }
    ```
    &#34;&#34;&#34;
    list_obj = [
        f&#34;{item[&#39;name&#39;]} ({_make_url_from_identifier(item[&#39;identifier&#39;])})&lt;br&gt;&#34;
        for item in summary_objs
    ]
    return &#34;&#34;.join(list_obj)


@app.get(&#34;/incomplete_descriptions&#34;, response_class=HTMLResponse)
async def get_incomplete_descriptions():
    &#34;&#34;&#34;Retrieve the number of PRONOM descriptions with status complete.&#34;&#34;&#34;
    summary = _get_summary()
    complete = [
        item
        for item in summary.get(&#34;pronom_data&#34;, [])
        if item[&#34;description&#34;] != &#34;complete&#34;
    ]
    return _make_formatted_list_from_summary_items(complete)


@app.get(&#34;/requires_signatures&#34;, response_class=HTMLResponse)
async def get_requires_signatures():
    &#34;&#34;&#34;Retrieve the number of PRONOM descriptions with status complete.&#34;&#34;&#34;
    summary = _get_summary()
    signatures = [
        item for item in summary.get(&#34;pronom_data&#34;, []) if item[&#34;signature&#34;] is not True
    ]
    return _make_formatted_list_from_summary_items(signatures)


def _get_auth():
    &#34;&#34;&#34;Retrieve the authentication information from the environment.&#34;&#34;&#34;
    load_dotenv(ENV_FILE)
    system_pass = os.getenv(&#34;SERVER_AUTH&#34;)
    digest = hashlib.sha256()
    digest.update(system_pass.strip().encode())
    return digest.hexdigest()


@app.put(&#34;/pronom_summary&#34;, tags=[TAG_PRONOM])
async def put_summary(
    request: Request,
    auth: Annotated[str | None, Header()] = None,
):
    &#34;&#34;&#34;Provides a mechanism to store the PRONOM version number.

    The so-called `auth` method in this function is a shot-to-medium
    term hack that allows the endpoint to be used locally.

    NB. The stakes are pretty low; if it&#39;s used even, letalone hacked
    we&#39;ll figure something more permanent out.
    &#34;&#34;&#34;
    system_pass = _get_auth()
    logger.info(system_pass)
    if not system_pass or auth != system_pass.strip():
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=&#34;incorrect auth token&#34;,
        )
    logger.info(&#34;auth OK&#34;)
    req = await request.json()
    version = req.get(&#34;version&#34;)
    summary = {}
    summary[&#34;summary&#34;] = req
    await _insert_version(f&#34;{version}&#34;, json.dumps(req))
    return {&#34;message&#34;: &#34;success&#34;}


def main():
    &#34;&#34;&#34;Primary entry point for this script.&#34;&#34;&#34;

    parser = argparse.ArgumentParser(
        prog=&#34;pronom-stats&#34;,
        description=&#34;PRONOM Stats API&#34;,
        epilog=&#34;for more information visit https://ffdev.info/&#34;,
    )

    parser.add_argument(
        &#34;--port&#34;,
        help=&#34;provide a port on which to run the app&#34;,
        required=False,
        default=26000,
    )

    args = parser.parse_args()

    logger.info(
        &#34;attempting API startup, try setting `--port` arg if there are any issues&#34;
    )

    import_str = &#34;src.pronom_stats.pronom_stats&#34;
    try:
        importlib.import_module(import_str)
        import_str = f&#34;{import_str}:app&#34;
    except ModuleNotFoundError:
        import_str = &#34;pronom_stats.pronom_stats:app&#34;
        logger.info(&#34;importing from %s&#34;, import_str)

    logging.info(&#34;ensure that environment is configured (e.g. SERVER_AUTH=&#39;badf00d&#39;)&#34;)

    uvicorn.run(
        import_str,
        host=&#34;0.0.0.0&#34;,
        port=int(args.port),
        access_log=False,
        log_level=&#34;info&#34;,
        reload=True,
    )


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.pronom_stats.pronom_stats.get_complete_descriptions_count"><code class="name flex">
<span>async def <span class="ident">get_complete_descriptions_count</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the number of PRONOM descriptions with status complete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/complete_description_count&#34;)
async def get_complete_descriptions_count():
    &#34;&#34;&#34;Retrieve the number of PRONOM descriptions with status complete.&#34;&#34;&#34;
    summary = _get_summary()
    complete = [
        item
        for item in summary.get(&#34;pronom_data&#34;, [])
        if item[&#34;description&#34;] == &#34;complete&#34;
    ]
    return len(complete)</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.get_complete_records_count"><code class="name flex">
<span>async def <span class="ident">get_complete_records_count</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the PRONOM version from the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/records_count&#34;, tags=[TAG_PRONOM])
async def get_complete_records_count():
    &#34;&#34;&#34;Retrieve the PRONOM version from the database.&#34;&#34;&#34;
    summary = _get_summary()
    return len(summary.get(&#34;pronom_data&#34;, []))</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.get_incomplete_descriptions"><code class="name flex">
<span>async def <span class="ident">get_incomplete_descriptions</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the number of PRONOM descriptions with status complete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/incomplete_descriptions&#34;, response_class=HTMLResponse)
async def get_incomplete_descriptions():
    &#34;&#34;&#34;Retrieve the number of PRONOM descriptions with status complete.&#34;&#34;&#34;
    summary = _get_summary()
    complete = [
        item
        for item in summary.get(&#34;pronom_data&#34;, [])
        if item[&#34;description&#34;] != &#34;complete&#34;
    ]
    return _make_formatted_list_from_summary_items(complete)</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.get_incomplete_descriptions_count"><code class="name flex">
<span>async def <span class="ident">get_incomplete_descriptions_count</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the number of PRONOM descriptions with status complete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/incomplete_description_count&#34;)
async def get_incomplete_descriptions_count():
    &#34;&#34;&#34;Retrieve the number of PRONOM descriptions with status complete.&#34;&#34;&#34;
    summary = _get_summary()
    complete = [
        item
        for item in summary.get(&#34;pronom_data&#34;, [])
        if item[&#34;description&#34;] != &#34;complete&#34;
    ]
    return len(complete)</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.get_pronom_summary"><code class="name flex">
<span>async def <span class="ident">get_pronom_summary</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the PRONOM summary information from the database.</p>
<p>Result should looks something like as follows:</p>
<pre><code class="language-json">    {
        &quot;version&quot;: &quot;v116&quot;,
        &quot;summary&quot;: {
            &quot;date&quot;: &quot;2023-11-23&quot;,
            &quot;latest_puid&quot;: &quot;fmt/1924&quot;,
            &quot;version&quot;: &quot;V116&quot;,
            &quot;sig_file&quot;: &quot;https://cdn.nationalarchives.gov.uk/documents/DROID_SignatureFile_V116.xml&quot;,
            &quot;container_sig&quot;: &quot;https://cdn.nationalarchives.gov.uk/documents/container-signature-20231127.xml&quot;,
            &quot;xpuid_const&quot;: &quot;x-fmt/455&quot;,
            &quot;pronom_data&quot;: [
                {
                    &quot;name&quot;: &quot;Broadcast WAVE 0 Generic&quot;,
                    &quot;description&quot;: &quot;complete&quot;,
                    &quot;signature&quot;: true,
                    &quot;identifier&quot;: &quot;fmt/1&quot;
                },
                {
                    &quot;name&quot;: &quot;Microsoft Word for Macintosh Document 3.0&quot;,
                    &quot;description&quot;: &quot;complete&quot;,
                    &quot;signature&quot;: true,
                    &quot;identifier&quot;: &quot;x-fmt/1&quot;
                }
            ]
        }
    }
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/pronom_summary&#34;, tags=[TAG_PRONOM])
async def get_pronom_summary():
    &#34;&#34;&#34;Retrieve the PRONOM summary information from the database.

    Result should looks something like as follows:

    ```json
        {
            &#34;version&#34;: &#34;v116&#34;,
            &#34;summary&#34;: {
                &#34;date&#34;: &#34;2023-11-23&#34;,
                &#34;latest_puid&#34;: &#34;fmt/1924&#34;,
                &#34;version&#34;: &#34;V116&#34;,
                &#34;sig_file&#34;: &#34;https://cdn.nationalarchives.gov.uk/documents/DROID_SignatureFile_V116.xml&#34;,
                &#34;container_sig&#34;: &#34;https://cdn.nationalarchives.gov.uk/documents/container-signature-20231127.xml&#34;,
                &#34;xpuid_const&#34;: &#34;x-fmt/455&#34;,
                &#34;pronom_data&#34;: [
                    {
                        &#34;name&#34;: &#34;Broadcast WAVE 0 Generic&#34;,
                        &#34;description&#34;: &#34;complete&#34;,
                        &#34;signature&#34;: true,
                        &#34;identifier&#34;: &#34;fmt/1&#34;
                    },
                    {
                        &#34;name&#34;: &#34;Microsoft Word for Macintosh Document 3.0&#34;,
                        &#34;description&#34;: &#34;complete&#34;,
                        &#34;signature&#34;: true,
                        &#34;identifier&#34;: &#34;x-fmt/1&#34;
                    }
                ]
            }
        }
    ```
    &#34;&#34;&#34;
    res = app.cur.execute(
        &#34;select version, summary from pronom order by rowid desc limit 1;&#34;
    )
    res = res.fetchone()
    ret = {}
    ret[&#34;version&#34;] = res[0]
    ret[&#34;summary&#34;] = json.loads(res[1])
    return ret</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.get_pronom_version"><code class="name flex">
<span>async def <span class="ident">get_pronom_version</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the PRONOM version from the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/pronom_version&#34;, tags=[TAG_PRONOM], response_class=HTMLResponse)
async def get_pronom_version() -&gt; str:
    &#34;&#34;&#34;Retrieve the PRONOM version from the database.&#34;&#34;&#34;
    res = app.cur.execute(&#34;select version from pronom order by rowid desc limit 1;&#34;)
    res = res.fetchone()
    return res[0]</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.get_requires_signatures"><code class="name flex">
<span>async def <span class="ident">get_requires_signatures</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the number of PRONOM descriptions with status complete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/requires_signatures&#34;, response_class=HTMLResponse)
async def get_requires_signatures():
    &#34;&#34;&#34;Retrieve the number of PRONOM descriptions with status complete.&#34;&#34;&#34;
    summary = _get_summary()
    signatures = [
        item for item in summary.get(&#34;pronom_data&#34;, []) if item[&#34;signature&#34;] is not True
    ]
    return _make_formatted_list_from_summary_items(signatures)</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.get_requires_signatures_count"><code class="name flex">
<span>async def <span class="ident">get_requires_signatures_count</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the number of PRONOM descriptions where signatures are
still required.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/requires_signature_count&#34;)
async def get_requires_signatures_count():
    &#34;&#34;&#34;Retrieve the number of PRONOM descriptions where signatures are
    still required.
    &#34;&#34;&#34;
    summary = _get_summary()
    signatures = [
        item for item in summary.get(&#34;pronom_data&#34;, []) if item[&#34;signature&#34;] is not True
    ]
    return len(signatures)</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.get_signature_files"><code class="name flex">
<span>async def <span class="ident">get_signature_files</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>List the signature files associated with the latest PRONOM
release.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/signature_files&#34;, response_class=HTMLResponse)
async def get_signature_files():
    &#34;&#34;&#34;List the signature files associated with the latest PRONOM
    release.
    &#34;&#34;&#34;
    summary = _get_summary()
    standard_sig = summary.get(&#34;sig_file&#34;)
    container_sig = summary.get(&#34;container_sig&#34;)
    return (
        f&#34;&lt;br&gt;&#34;
        f&#34;&lt;ul&gt;&#34;
        f&#34;&lt;li&gt;Standard signature file: &lt;a href=&#39;{standard_sig}&#39;&gt;{standard_sig}&lt;/a&gt;&lt;/li&gt;&#34;
        f&#34;&lt;li&gt;Container signature file: &lt;a href=&#39;{container_sig}&#39;&gt;{container_sig}&lt;/a&gt;&lt;/li&gt;&#34;
        f&#34;&lt;/ul&gt;&#34;
    )</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.get_signatures_count"><code class="name flex">
<span>async def <span class="ident">get_signatures_count</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the number of PRONOM descriptions with status complete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/signature_count&#34;)
async def get_signatures_count():
    &#34;&#34;&#34;Retrieve the number of PRONOM descriptions with status complete.&#34;&#34;&#34;
    summary = _get_summary()
    signatures = [
        item for item in summary.get(&#34;pronom_data&#34;, []) if item[&#34;signature&#34;] is True
    ]
    return len(signatures)</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.init_db"><code class="name flex">
<span>async def <span class="ident">init_db</span></span>(<span>cur: sqlite3.Cursor)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the database if it doesn't exist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def init_db(cur: sqlite3.Cursor):
    &#34;&#34;&#34;Initialize the database if it doesn&#39;t exist.&#34;&#34;&#34;
    try:
        cur.execute(&#34;CREATE TABLE pronom(version, summary)&#34;)
    except sqlite3.OperationalError:
        # database is already setup.
        pass</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.lifespan"><code class="name flex">
<span>async def <span class="ident">lifespan</span></span>(<span>context: fastapi.applications.FastAPI)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the database connection for the life of the app.s</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@asynccontextmanager
async def lifespan(context: FastAPI):
    &#34;&#34;&#34;Load the database connection for the life of the app.s&#34;&#34;&#34;
    _load_config()
    con = sqlite3.connect(os.path.join(&#34;/var&#34;, &#34;tmp&#34;, &#34;pronom-stats.db&#34;))
    context.cur = con.cursor()
    await init_db(context.cur)
    yield</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Primary entry point for this script.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;Primary entry point for this script.&#34;&#34;&#34;

    parser = argparse.ArgumentParser(
        prog=&#34;pronom-stats&#34;,
        description=&#34;PRONOM Stats API&#34;,
        epilog=&#34;for more information visit https://ffdev.info/&#34;,
    )

    parser.add_argument(
        &#34;--port&#34;,
        help=&#34;provide a port on which to run the app&#34;,
        required=False,
        default=26000,
    )

    args = parser.parse_args()

    logger.info(
        &#34;attempting API startup, try setting `--port` arg if there are any issues&#34;
    )

    import_str = &#34;src.pronom_stats.pronom_stats&#34;
    try:
        importlib.import_module(import_str)
        import_str = f&#34;{import_str}:app&#34;
    except ModuleNotFoundError:
        import_str = &#34;pronom_stats.pronom_stats:app&#34;
        logger.info(&#34;importing from %s&#34;, import_str)

    logging.info(&#34;ensure that environment is configured (e.g. SERVER_AUTH=&#39;badf00d&#39;)&#34;)

    uvicorn.run(
        import_str,
        host=&#34;0.0.0.0&#34;,
        port=int(args.port),
        access_log=False,
        log_level=&#34;info&#34;,
        reload=True,
    )</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.put_summary"><code class="name flex">
<span>async def <span class="ident">put_summary</span></span>(<span>request: starlette.requests.Request, auth: typing.Annotated[str | None, Header(PydanticUndefined)] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides a mechanism to store the PRONOM version number.</p>
<p>The so-called <code>auth</code> method in this function is a shot-to-medium
term hack that allows the endpoint to be used locally.</p>
<p>NB. The stakes are pretty low; if it's used even, letalone hacked
we'll figure something more permanent out.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.put(&#34;/pronom_summary&#34;, tags=[TAG_PRONOM])
async def put_summary(
    request: Request,
    auth: Annotated[str | None, Header()] = None,
):
    &#34;&#34;&#34;Provides a mechanism to store the PRONOM version number.

    The so-called `auth` method in this function is a shot-to-medium
    term hack that allows the endpoint to be used locally.

    NB. The stakes are pretty low; if it&#39;s used even, letalone hacked
    we&#39;ll figure something more permanent out.
    &#34;&#34;&#34;
    system_pass = _get_auth()
    logger.info(system_pass)
    if not system_pass or auth != system_pass.strip():
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=&#34;incorrect auth token&#34;,
        )
    logger.info(&#34;auth OK&#34;)
    req = await request.json()
    version = req.get(&#34;version&#34;)
    summary = {}
    summary[&#34;summary&#34;] = req
    await _insert_version(f&#34;{version}&#34;, json.dumps(req))
    return {&#34;message&#34;: &#34;success&#34;}</code></pre>
</details>
</dd>
<dt id="src.pronom_stats.pronom_stats.redirect_root_to_docs"><code class="name flex">
<span>def <span class="ident">redirect_root_to_docs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Redirect a user calling the API root '/' to the API
documentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/&#34;, include_in_schema=False)
def redirect_root_to_docs():
    &#34;&#34;&#34;Redirect a user calling the API root &#39;/&#39; to the API
    documentation.
    &#34;&#34;&#34;
    return RedirectResponse(url=&#34;/docs&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.pronom_stats" href="index.html">src.pronom_stats</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.pronom_stats.pronom_stats.get_complete_descriptions_count" href="#src.pronom_stats.pronom_stats.get_complete_descriptions_count">get_complete_descriptions_count</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.get_complete_records_count" href="#src.pronom_stats.pronom_stats.get_complete_records_count">get_complete_records_count</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.get_incomplete_descriptions" href="#src.pronom_stats.pronom_stats.get_incomplete_descriptions">get_incomplete_descriptions</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.get_incomplete_descriptions_count" href="#src.pronom_stats.pronom_stats.get_incomplete_descriptions_count">get_incomplete_descriptions_count</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.get_pronom_summary" href="#src.pronom_stats.pronom_stats.get_pronom_summary">get_pronom_summary</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.get_pronom_version" href="#src.pronom_stats.pronom_stats.get_pronom_version">get_pronom_version</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.get_requires_signatures" href="#src.pronom_stats.pronom_stats.get_requires_signatures">get_requires_signatures</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.get_requires_signatures_count" href="#src.pronom_stats.pronom_stats.get_requires_signatures_count">get_requires_signatures_count</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.get_signature_files" href="#src.pronom_stats.pronom_stats.get_signature_files">get_signature_files</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.get_signatures_count" href="#src.pronom_stats.pronom_stats.get_signatures_count">get_signatures_count</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.init_db" href="#src.pronom_stats.pronom_stats.init_db">init_db</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.lifespan" href="#src.pronom_stats.pronom_stats.lifespan">lifespan</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.main" href="#src.pronom_stats.pronom_stats.main">main</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.put_summary" href="#src.pronom_stats.pronom_stats.put_summary">put_summary</a></code></li>
<li><code><a title="src.pronom_stats.pronom_stats.redirect_root_to_docs" href="#src.pronom_stats.pronom_stats.redirect_root_to_docs">redirect_root_to_docs</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
